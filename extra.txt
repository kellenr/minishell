

/*
 * Function to expand variables in a given string.
 * Supports expansion of `~`, environment variables (`$VAR`), and the special variable `$?`.
 */
char *expand_variables(const char *str, int last_status)
{
	char *expanded_str = NULL;

	if (!str)
		return NULL;
	if (str[0] == '~' && (str[1] == '/' || str[1] == '\0'))
	{
		const char *home = getenv("HOME");
		if (home)
		{
			size_t len = strlen(home) + strlen(str);
			expanded_str = malloc(len);
			if (expanded_str)
			{
				strcpy(expanded_str, home);
				strcat(expanded_str, str + 1);
			}
			return expanded_str;
		}
	}

	// Handle environment variable expansion and special variable `$?`
	if (str[0] == '$')
	{
		if (strcmp(str, "$?") == 0)
		{
			return expand_status_var(last_status);
		}
		else
		{
			return (expand_env_var(str + 1)); // Skip the `$` and get the env variable
		}
	}

	return (ft_strdup(str));
}

/*
 * Function to expand the special variable `$?`.
 * Returns the exit status of the last executed command as a string.
 */
char *expand_status_var(int status)
{
	char *status_str = malloc(12); // Enough to hold an integer as a string
	if (status_str)
	{
		snprintf(status_str, 12, "%d", status);
	}
	return status_str;
}

/*
 * Function to expand environment variables.
 * Takes the variable name as an argument and returns its value.
 * If the variable is not set, returns an empty string.
 */
char *expand_env_var(const char *var)
{
	const char *value = getenv(var);
	if (value)
	{
		return (ft_strdup(value));
	}
	return (ft_strdup(""));
}

/*
 * Function to tokenize the input string into a linked list of tokens.
 * Takes the input string as an argument.
 * Returns the head of the token list.
 */
/* t_token	*tokenize(char *input)
{
	t_token	*head;
	char	*token;
	char	*pre_input;
	char	*cleaned_token;

	head = NULL;
	pre_input = process_input(input);
	token = ft_strtoke(pre_input, " ");
	while (token)
	{
		if (*token == '\'' || *token == '\"')
			cleaned_token = remove_quotes(token);
		else
			cleaned_token = ft_strdup(token);
		add_token(&head, cleaned_token);
		free(cleaned_token);
		token = ft_strtoke(NULL, " ");
	}
	free(pre_input);
	return (head);
} */
